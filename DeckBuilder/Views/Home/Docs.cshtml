@{
    ViewBag.Title = "About Us";
}


<html><head><title>Protoplasm Python Documentation</title><style type="text/css">ol{margin:0;padding:0}.c6{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c0{direction:ltr;margin-left:36pt}.c2{font-weight:bold}.c4{height:11pt}.c1{direction:ltr}.c3{font-style:italic}.c5{text-indent:36pt}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style></head><body><p class="c1"><span class="c2">Anatomy of a Protoplasm Game</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">GameState </span><span>- Each game is primarily defined by a Python class that inherits from the GameState class. In addition to storing the game state, this class also defines how your game interacts with the Protoplasm server and client-side javascript engine.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">Initialization </span><span>- The first thing your game has to do is to generate an initial game state based on the number of players involved. The input to your initialization function comes in the form of a list of &ldquo;Seats&rdquo;. It is strongly recommended that you call the GameState base __init__ function as the first step of your initialization. This will take care of everything that isn&rsquo;t unique to your game. Specifically, this will initialize a list of PlayerContexts from the Seat list and set your game&rsquo;s TableId. After calling the GameState __init__, you&rsquo;ll have the following already set up:</span></p><p class="c0"><span>- The </span><span class="c3">player_contexts</span><span>&nbsp;attribute will be set to a list of PlayerContext instance. Each PlayerContext includes at minimum a player&rsquo;s name and player_id. Later, you can add any additional player specific data you need to.</span></p><p class="c0"><span>- The </span><span class="c3">game_over</span><span>&nbsp;attribute will be initially set to False.</span></p><p class="c0"><span>- The </span><span class="c3">logs</span><span>&nbsp;attribute will be set to an empty list.</span></p><p class="c0"><span>- The </span><span class="c3">table_id</span><span>&nbsp;attribute will be set to the current game&rsquo;s TableId.</span></p><p class="c0"><span>- The </span><span class="c3">active_player_id</span><span>&nbsp;will be set to the first player. This works with some other turn-order related helper functions, but feel free to ignore these and handle the question of &ldquo;who&rsquo;s turn is it?&rdquo; on your own.</span></p><p class="c1"><span>With these attributes set, you can go ahead and start adding your own game-specific state. </span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">View </span><span>- After intialization, the server will call your game&rsquo;s </span><span class="c3">view</span><span>&nbsp;function. The </span><span class="c3">view</span><span>&nbsp;function&rsquo;s job is to return a specially formatted object that can be passed along and displayed by the protoplasm javascript engine. This will be in the form of a dictionary with the following required key-value pairs</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- &ldquo;tableId&rdquo;: The TableId corresponding to your game instance. If you called the base GameState __init__, you should be able to get this as </span><span class="c3">self.table_id</span><span>.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- &ldquo;logs&rdquo;: A list of strings to be displayed in the log window. Again, if you&rsquo;re following convention, this should just be </span><span class="c3">self.logs</span><span>.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- &ldquo;drawList&rdquo;: This is the meat and potatoes of the view. It must be a list of specially constructed view dictionaries corresponding to the game objects you want to display. For example, if you have a hex board, you might add the following to the draw list.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view[&ldquo;drawList&rdquo;] = []</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view[&ldquo;drawList&rdquo;].append(self.hexBoard.view(250,320,50))</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>Which would result in the javascript engine displaying your hex grid centered at (250,320) with a tile radius of 50 pixels. In addition, there are some other helper functions to add view items such as text_view and image_view.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view[&ldquo;drawList&rdquo;].append(protoplasm.text_view(100,100,&rdquo;Hey, it&rsquo;s some text!&rdquo;, &ldquo;16px Verdana&rdquo;, &ldquo;Red&rdquo;)</span></p><p class="c0 c5"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;view[&ldquo;drawList&rdquo;].append(protoplasm.image_view(100,100,50,50,&rdquo;www.blahblah.com/images/test.png&rdquo;)</span></p><p class="c4 c1"><span class="c2"></span></p><p class="c1"><span>Finally, when you return that object, protoplasm should take care of the rest and display your game to the player.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">Update </span><span>- Once a player has a view of your game, they&rsquo;ll be able to interact with your boards, cards, decks, etc... Whenever the player chooses a card from their hand or selects a tile on the board, your game state&rsquo;s Update function will be called along with a GameUpdate parameter.</span></p><p class="c4 c1"><span class="c2"></span></p><p class="c0"><span class="c2">GameUpdate</span><span>&nbsp;- Test class that simulates a game&rsquo;s update input. Contains the following data:</span></p><p class="c0"><span>- player_id: Id of the player submitting this update.</span></p><p class="c0"><span>- update_source: Name of the game object that caused the interaction</span></p><p class="c0"><span>- x: First grid coordinate</span></p><p class="c0"><span>- y: Second grid coordinate</span></p><p class="c0"><span>- index: Index into a list</span></p><p class="c0"><span>- direction: Side of object that was clicked.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>It&rsquo;s the responsibility of your update function to check which game object is being manipulated and read the appropriate attributes. For example, the x and y coordinates are used if the </span><span class="c3">update_source</span><span>&nbsp;is some kind of grid, but for a </span><span class="c3">Hand</span><span>&nbsp;object, only the </span><span class="c3">index</span><span>&nbsp;attribute will be meaningful.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>Once you&rsquo;ve interpreted what action the user took, all you need to do is update your internal game state and protoplasm will report your changes back to the players by calling the </span><span class="c3">view</span><span>&nbsp;function on your latest state.</span></p><p class="c4 c1"><span></span></p><p class="c4 c1"><span></span></p><p class="c4 c1"><span></span></p><p class="c4 c1"><span></span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">Decoration Functions </span><span>- Use these to display non-interactive data and decorations. For example, text_view can be used to add player names, scores, resource values, etc... Use image_view for ui decorations or any images that will never need to be clicked on.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">text_view(x,y,text,font,color) </span><span>- Return a view object for a text chunk.</span></p><p class="c1"><span>- x: Center of text.</span></p><p class="c1"><span>- y: Center of text.</span></p><p class="c1"><span>- text: Text to display</span></p><p class="c1"><span>- font: Font size and style to use. Eg. &ldquo;16px Verdana&rdquo;</span></p><p class="c1"><span>- color: Font color to use. Eg. &ldquo;Black&rdquo;, &ldquo;Red&rdquo;</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">image_view(x,y,width,height,url) </span><span>- Return a view object for a static image.</span></p><p class="c1"><span>- x: Center of image.</span></p><p class="c1"><span>- y: Center of image.</span></p><p class="c1"><span>- width: Width of image.</span></p><p class="c1"><span>- height: Height of image.</span></p><p class="c1"><span>- url: Url of image</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">GameObjects </span><span>- These form the core of your game and represent the types of components you&rsquo;d interact with while playing a physical board game. Objects such as boards, cards, hands, decks, pieces, and tokens are all derived from the GameObject class.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>- name: String identifier for the object. This will be used in the game&rsquo;s Update logic to indicate from which GameObject the update originated from. These are NOT required to be unique, and need only be descriptive enough for your Update logic to interpret. For example, if your game involves two separate Hands of cards &ldquo;Events&rdquo; and &ldquo;Items&rdquo;, the </span><span class="c3">update_source</span><span>&nbsp;attribute would be used to indicate which hand the card is being selected from.</span></p><p class="c1"><span>- type: Used by the protoplasm javascript engine to render your game objects. This will be set automatically in game objects&rsquo; constructors and should not be modified.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">Hand </span><span>- This represents a set of cards visible to one or more players. Players interact with this object by choosing a card from it.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>-__init__(name,frame_url): Creates a new hand of cards. </span><span class="c3">frame_url</span><span>&nbsp;represents the default card background image.</span></p><p class="c1"><span>- add(card): Add a card to the hand.</span></p><p class="c1"><span>- clear_selection(): Clears the </span><span class="c3">selectable</span><span>&nbsp;and </span><span class="c3">highlight_url</span><span>&nbsp;attributes from all elements.</span></p><p class="c1"><span>- take(index): Returns card at </span><span class="c3">index</span><span>, removing it from the hand.</span></p><p class="c1"><span>- count(): Return the number of cards in the hand</span></p><p class="c1"><span>- card(index): Return the card at </span><span class="c3">indexi</span></p><p class="c1"><span>- view(x,y,card_width, card_height): Return view object for CardSet to be displayed by the protoplasm javascript engine. </span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- x: Coordinate of left-most card.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- y: Vertical location to display cards.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- card_width: Width in pixels of each card.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- card_height: Width in pixels of each card.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>- hidden_view(x,y,card_width, card_height): Returns a special view object for card that obscures the actual contents. Use this to show a player their opponent&rsquo;s hands.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- x: Coordinate of left-most card.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- y: Vertical location to display cards.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- card_width: Width in pixels of each card.</span></p><p class="c1"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- card_height: Width in pixels of each card.</span></p><p class="c1"><span>- deselect(): Deselect all cards.</span></p><p class="c1"><span>- select(index): Select card at given index.</span></p><p class="c1"><span>- selected_card(): Returns the currently selected card, if one exists.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">Deck </span><span>- This helper object represents a stack of cards.</span></p><p class="c1"><span>__init__(name): Creates a new empty deck.</span></p><p class="c1"><span>shuffle(): Randomly shuffles the deck.</span></p><p class="c1"><span>draw(): Return and remove the top card of the deck. Return None if Deck is empty.</span></p><p class="c1"><span>draw_with_discard(discard): Return and remove the top card of the deck. If Deck is empty, shuffle the given discard pile into the deck first. If both Deck and Discard are empty, return None.</span></p><p class="c1"><span>add(card): Add the given card to the top of the deck.</span></p><p class="c1 c4"><span></span></p><p class="c1"><span class="c2">HexBoard </span><span>- Creates a hex-grid board. [Link to description of coordinate system]</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>__init__(name,side_length): Return a regular hex grid with given side length.</span></p><p class="c1"><span>get_abc_coords(a,b): Return 3-tuple of coordinates (a,b,c)</span></p><p class="c1"><span>top_piece(a,b): Return top piece at coordinates (a,b)</span></p><p class="c1"><span>is_empty(a,b): Return true if there are no pieces on the tile at coordinates (a,b)</span></p><p class="c1"><span>pieces(a,b): Return list of pieces at coordinates (a,b)</span></p><p class="c1"><span>clear_pieces(a,b): Removes all pieces at coordinates (a,b)</span></p><p class="c1"><span>tile_at(a,b): Return HexTile at coordinates (a,b)</span></p><p class="c1"><span>clear_selection(): Clears the </span><span class="c3">selectable</span><span>&nbsp;and </span><span class="c3">highlight_url</span><span>&nbsp;attributes from all elements.</span></p><p class="c1"><span>view(x,y,radius): Return a view of the hex board centered at (x,y) with tile radius radius.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">SquareBoard</span><span>- Creates a square-grid board. X coord is horizontal left-to-right. Y coord is vertical top-to-bottom.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span>__init__(name,width,height): Return a rectangular grid with given width and height.</span></p><p class="c1"><span>top_piece(x,y): Return top piece at coordinates (x,y)</span></p><p class="c1"><span>add_piece(x,y,piece): Adds piece to the tile at coordinates(x,y)</span></p><p class="c1"><span>is_empty(x,y): Return true if there are no pieces on the tile at coordinates (x,y)</span></p><p class="c1"><span>pieces(x,y): Return list of pieces at coordinates (x,y)</span></p><p class="c1"><span>tile_at(x,y): Return Tile at coordinates (x,y)</span></p><p class="c1"><span>clear_pieces(x,y): Removes all pieces at coordinates (x,y)</span></p><p class="c1"><span>clear_selection(): Clears the </span><span class="c3">selectable</span><span>&nbsp;and </span><span class="c3">highlight_url</span><span>&nbsp;attributes from all elements.</span></p><p class="c1"><span>view(x,y,x_tile_width,tile_height): Return a view of the square board centered at (x,y) with tile size given by (tile_width,tile_height)</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">InfoWindow </span><span>- Creates a viewing area for dynamic text. Used to display information about whatever the user is hovering over. May be a fixed location or a tooltip that hovers at an offset from the mouse location.</span></p><p class="c1"><span>__init__(name,width,height,url,font,color) - Create an info window with the given dimensions, background url, and text style.</span></p><p class="c1"><span>set_location(x,y) - Set the infowindow to a static location at (x,y)</span></p><p class="c1"><span>view() - Return a view object for the info window.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">Tile </span><span>- Creates a tile on a board. These populate Square and Hex boards and may be retrieved by the tile_at functions.</span></p><p class="c1"><span>top_piece() - Return the top piece on the tile.</span></p><p class="c1"><span>pieces() - Return a list of pieces on the tile.</span></p><p class="c1"><span>view() - Return a view of the Tile.</span></p><p class="c1"><span>add_piece(piece): Adds piece to the tile</span></p><p class="c1"><span>is_empty(): Return true if there are no pieces on the tile.</span></p><p class="c1"><span>clear(): Remove all pieces from tile</span></p><p class="c1"><span>pieces - A list of pieces on the tile.</span></p><p class="c1"><span>selectable - Indicates if the tile can be clicked on by the user.</span></p><p class="c1"><span>highlight_url - Optional: Image (usually transparent) to be displayed overtop the piece&rsquo;s image.</span></p><p class="c1"><span>direction - Optional: Indicates if the piece is rotated. Meaning depends on context. Not used for Hands, modulo 4 for Square Boards, and modulo 6 for Hex Boards. If not given, the default &ldquo;up&rdquo; is used.</span></p><p class="c1"><span>hover_window - Optional: Name of an InfoWindow to display hover text to.</span></p><p class="c1"><span>hover_text - Optional: Text description of piece for display in InfoWindow described by </span><span class="c3">hover_window</span><span>.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">GamePiece </span><span>- A generic game piece. This may be a piece on the board, or a card, or any other basic game primitive.</span></p><p class="c1"><span>__init__(name,url) - Create a new piece with a given name and url.</span></p><p class="c1"><span>hidden_view() - Return a view of the game piece stripped of its image and name.</span></p><p class="c1"><span>view() - Return a view of the game piece.</span></p><p class="c1"><span>selectable - Indicates that this game piece can be clicked on by the user.</span></p><p class="c1"><span>base_urls - Optional: List of images that are displayed underneath the piece&rsquo;s main image.</span></p><p class="c1"><span>highlight_url - Optional: Image (usually transparent) to be displayed overtop the piece&rsquo;s image.</span></p><p class="c1"><span>hover_window - Optional: Name of an InfoWindow to display hover text to.</span></p><p class="c1"><span>hover_text - Optional: Text description of piece for display in InfoWindow described by </span><span class="c3">hover_window</span><span>.</span></p><p class="c1"><span>direction - Optional: Indicates if the piece is rotated. Meaning depends on context. Not used for Hands, modulo 4 for Square Boards, and modulo 6 for Hex Boards. If not given, the default &ldquo;up&rdquo; is used.</span></p><p class="c1"><span>tokens - Optional: Indicates a list of tokens attached to the piece. Tokens are rendered on top of the main url.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">Token</span><span>&nbsp;- Very simple visual item attached to a piece.</span></p><p class="c1"><span>__init__(name,url) - Create a new token with a given name and url.</span></p><p class="c1"><span>view() - Return a view of the token.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">PlayerContext </span><span>- Represents all of the game data unique to a given player. These are not used by the view, and developers are encouraged to add whatever additional data to this as necessary. Generally, these are created automatically by calling the GameState base constructor.</span></p><p class="c1"><span>__init__(player_id,name) - Create a new player context with a given id and name.</span></p><p class="c1"><span>player_id - Unique identifying number for the player.</span></p><p class="c1"><span>name - Player&rsquo;s name.</span></p><p class="c4 c1"><span></span></p><p class="c1"><span class="c2">GameState </span><span>- Base class for your game&rsquo;s state. Your custom game state should inherit from the GameState class.</span></p><p class="c1"><span>__init__(seats) - Base constructor. All gamestates should call this immediately in their constructor. Doing so will initialize a list of PlayerContexts for all players involved in the game and initialize several important attributes.</span></p><p class="c1"><span>log(message) - Adds a string message to the game state&rsquo;s logs.</span></p><p class="c1"><span>get_player_context(player_id) - Returns the context associated with the given player id.</span></p><p class="c1"><span>advance_active_player() - Increments the active player index to the next in the list. This will often be a useful helper method unless your game implements a non-standard turn sequence.</span></p><p class="c1"><span>player_contexts - List of PlayerContexts. Populated by the constructor with basic contexts containing the involved players&rsquo; names and ids.</span></p><p class="c1"><span>game_over - Set to False by the constructor, but should be set to True when the game is complete.</span></p><p class="c1"><span>table_id - Unique identifier for the table containing this particular game instance. This will be set automatically by the constructor.</span></p><p class="c1"><span>active_player_index - Index into the </span><span class="c3">player_contexts</span><span>&nbsp;list for the currently active player. If your game uses a non-standard turn order, you may ignore this attribute. Set to 0 by the constructor.</span></p><p class="c1"><span>active_player_id - Id of the currently active player. If your game uses a non-standard turn order, you may ignore this attribute. Set to the first element of the </span><span class="c3">player_contexts</span><span>&nbsp;list by the constructor.</span></p></body></html>
